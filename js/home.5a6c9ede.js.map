{"version":3,"file":"js/home.5a6c9ede.js","mappings":"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","sources":["webpack://word-press/../../../../../../packages/components/carousel/src/carousel.ts","webpack://word-press/../../../../packages/tokens/carousel.ts","webpack://word-press/../../../../../../packages/components/carousel/src/carousel.vue","webpack://word-press/../../../../../../packages/components/carousel/src/carousel-item.ts","webpack://word-press/../../../../../../packages/components/carousel/src/carousel-item.vue","webpack://word-press/../../../../../packages/components/carousel/index.ts","webpack://word-press/./src/views/home/util.ts","webpack://word-press/./src/views/home/index.vue?ef49","webpack://word-press/./src/views/home/index.vue","webpack://word-press/./node_modules/lodash-es/_Symbol.js","webpack://word-press/./node_modules/lodash-es/_getRawTag.js","webpack://word-press/./node_modules/lodash-es/_objectToString.js","webpack://word-press/./node_modules/lodash-es/_baseGetTag.js","webpack://word-press/./node_modules/lodash-es/_freeGlobal.js","webpack://word-press/./node_modules/lodash-es/_root.js","webpack://word-press/./node_modules/lodash-es/isObject.js","webpack://word-press/./node_modules/lodash-es/isObjectLike.js","webpack://word-press/./node_modules/lodash-es/isSymbol.js","webpack://word-press/./node_modules/lodash-es/now.js","webpack://word-press/./node_modules/lodash-es/_trimmedEndIndex.js","webpack://word-press/./node_modules/lodash-es/_baseTrim.js","webpack://word-press/./node_modules/lodash-es/toNumber.js","webpack://word-press/./node_modules/lodash-es/debounce.js","webpack://word-press/./node_modules/lodash-es/throttle.js"],"sourcesContent":["import { buildProps, isNumber } from '@element-plus/utils'\nimport type { ExtractPropTypes } from 'vue'\nimport type Carousel from './carousel.vue'\n\nexport const carouselProps = buildProps({\n  initialIndex: {\n    type: Number,\n    default: 0,\n  },\n  height: {\n    type: String,\n    default: '',\n  },\n  trigger: {\n    type: String,\n    values: ['hover', 'click'],\n    default: 'hover',\n  },\n  autoplay: {\n    type: Boolean,\n    default: true,\n  },\n  interval: {\n    type: Number,\n    default: 3000,\n  },\n  indicatorPosition: {\n    type: String,\n    values: ['', 'none', 'outside'],\n    default: '',\n  },\n  indicator: {\n    type: Boolean,\n    default: true,\n  },\n  arrow: {\n    type: String,\n    values: ['always', 'hover', 'never'],\n    default: 'hover',\n  },\n  type: {\n    type: String,\n    values: ['', 'card'],\n    default: '',\n  },\n  loop: {\n    type: Boolean,\n    default: true,\n  },\n  direction: {\n    type: String,\n    values: ['horizontal', 'vertical'],\n    default: 'horizontal',\n  },\n  pauseOnHover: {\n    type: Boolean,\n    default: true,\n  },\n} as const)\n\nexport const carouselEmits = {\n  change: (current: number, prev: number) => [current, prev].every(isNumber),\n}\n\nexport type CarouselProps = ExtractPropTypes<typeof carouselProps>\nexport type CarouselEmits = typeof carouselEmits\n\nexport type CarouselInstance = InstanceType<typeof Carousel>\n","import type { InjectionKey, Ref } from 'vue'\n\nimport type { CarouselItemProps } from '@element-plus/components/carousel'\n\nexport type CarouselItemStates = {\n  hover: boolean\n  translate: number\n  scale: number\n  active: boolean\n  ready: boolean\n  inStage: boolean\n  animating: boolean\n}\n\nexport type CarouselItemContext = {\n  props: CarouselItemProps\n  states: CarouselItemStates\n  uid: number | undefined\n  translateItem: (index: number, activeIndex: number, oldIndex?: number) => void\n}\n\nexport type CarouselContext = {\n  root: Ref<HTMLElement | undefined>\n  items: Ref<CarouselItemContext[]>\n  isCardType: Ref<boolean>\n  isVertical: Ref<boolean>\n  loop: boolean\n  addItem: (item: CarouselItemContext) => void\n  removeItem: (uid: number | undefined) => void\n  setActiveItem: (index: number) => void\n}\n\nexport const carouselContextKey: InjectionKey<CarouselContext> =\n  Symbol('carouselContextKey')\n","<template>\n  <div\n    ref=\"root\"\n    :class=\"carouselClasses\"\n    @mouseenter.stop=\"handleMouseEnter\"\n    @mouseleave.stop=\"handleMouseLeave\"\n  >\n    <div :class=\"ns.e('container')\" :style=\"{ height: height }\">\n      <transition v-if=\"arrowDisplay\" name=\"carousel-arrow-left\">\n        <button\n          v-show=\"\n            (arrow === 'always' || hover) && (props.loop || activeIndex > 0)\n          \"\n          type=\"button\"\n          :class=\"[ns.e('arrow'), ns.em('arrow', 'left')]\"\n          @mouseenter=\"handleButtonEnter('left')\"\n          @mouseleave=\"handleButtonLeave\"\n          @click.stop=\"throttledArrowClick(activeIndex - 1)\"\n        >\n          <ElIcon>\n            <ArrowLeft />\n          </ElIcon>\n        </button>\n      </transition>\n      <transition v-if=\"arrowDisplay\" name=\"carousel-arrow-right\">\n        <button\n          v-show=\"\n            (arrow === 'always' || hover) &&\n            (props.loop || activeIndex < items.length - 1)\n          \"\n          type=\"button\"\n          :class=\"[ns.e('arrow'), ns.em('arrow', 'right')]\"\n          @mouseenter=\"handleButtonEnter('right')\"\n          @mouseleave=\"handleButtonLeave\"\n          @click.stop=\"throttledArrowClick(activeIndex + 1)\"\n        >\n          <ElIcon>\n            <ArrowRight />\n          </ElIcon>\n        </button>\n      </transition>\n      <slot />\n    </div>\n    <ul v-if=\"indicatorPosition !== 'none'\" :class=\"indicatorsClasses\">\n      <li\n        v-for=\"(item, index) in items\"\n        :key=\"index\"\n        :class=\"[\n          ns.e('indicator'),\n          ns.em('indicator', direction),\n          ns.is('active', index === activeIndex),\n        ]\"\n        @mouseenter=\"throttledIndicatorHover(index)\"\n        @click.stop=\"handleIndicatorClick(index)\"\n      >\n        <button :class=\"ns.e('button')\">\n          <span v-if=\"hasLabel\">{{ item.props.label }}</span>\n        </button>\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  shallowRef,\n  unref,\n  watch,\n} from 'vue'\nimport { throttle } from 'lodash-unified'\nimport { useResizeObserver } from '@vueuse/core'\nimport { debugWarn, isString } from '@element-plus/utils'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight } from '@element-plus/icons-vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport { carouselContextKey } from '@element-plus/tokens'\nimport { carouselEmits, carouselProps } from './carousel'\nimport type { CarouselItemContext } from '@element-plus/tokens'\n\ndefineOptions({\n  name: 'ElCarousel',\n})\n\nconst props = defineProps(carouselProps)\nconst emit = defineEmits(carouselEmits)\nconst ns = useNamespace('carousel')\nconst COMPONENT_NAME = 'ElCarousel'\nconst THROTTLE_TIME = 300\n\n// refs\nconst activeIndex = ref(-1)\nconst timer = ref<ReturnType<typeof setInterval> | null>(null)\nconst hover = ref(false)\nconst root = ref<HTMLDivElement>()\nconst items = ref<Array<CarouselItemContext>>([])\n\n// computed\nconst arrowDisplay = computed(\n  () => props.arrow !== 'never' && !unref(isVertical)\n)\n\nconst hasLabel = computed(() => {\n  return items.value.some((item) => item.props.label.toString().length > 0)\n})\n\nconst carouselClasses = computed(() => {\n  const classes = [ns.b(), ns.m(props.direction)]\n  if (unref(isCardType)) {\n    classes.push(ns.m('card'))\n  }\n  return classes\n})\n\nconst indicatorsClasses = computed(() => {\n  const classes = [ns.e('indicators'), ns.em('indicators', props.direction)]\n  if (hasLabel.value) {\n    classes.push(ns.em('indicators', 'labels'))\n  }\n  if (props.indicatorPosition === 'outside' || unref(isCardType)) {\n    classes.push(ns.em('indicators', 'outside'))\n  }\n  return classes\n})\n\nconst isCardType = computed(() => props.type === 'card')\nconst isVertical = computed(() => props.direction === 'vertical')\n\n// methods\nconst throttledArrowClick = throttle(\n  (index: number) => {\n    setActiveItem(index)\n  },\n  THROTTLE_TIME,\n  { trailing: true }\n)\n\nconst throttledIndicatorHover = throttle((index: number) => {\n  handleIndicatorHover(index)\n}, THROTTLE_TIME)\n\nfunction pauseTimer() {\n  if (timer.value) {\n    clearInterval(timer.value)\n    timer.value = null\n  }\n}\n\nfunction startTimer() {\n  if (props.interval <= 0 || !props.autoplay || timer.value) return\n  timer.value = setInterval(() => playSlides(), props.interval)\n}\n\nconst playSlides = () => {\n  if (activeIndex.value < items.value.length - 1) {\n    activeIndex.value = activeIndex.value + 1\n  } else if (props.loop) {\n    activeIndex.value = 0\n  }\n}\n\nfunction setActiveItem(index: number | string) {\n  if (isString(index)) {\n    const filteredItems = items.value.filter(\n      (item) => item.props.name === index\n    )\n    if (filteredItems.length > 0) {\n      index = items.value.indexOf(filteredItems[0])\n    }\n  }\n  index = Number(index)\n  if (Number.isNaN(index) || index !== Math.floor(index)) {\n    debugWarn(COMPONENT_NAME, 'index must be integer.')\n    return\n  }\n  const itemCount = items.value.length\n  const oldIndex = activeIndex.value\n  if (index < 0) {\n    activeIndex.value = props.loop ? itemCount - 1 : 0\n  } else if (index >= itemCount) {\n    activeIndex.value = props.loop ? 0 : itemCount - 1\n  } else {\n    activeIndex.value = index\n  }\n  if (oldIndex === activeIndex.value) {\n    resetItemPosition(oldIndex)\n  }\n  resetTimer()\n}\n\nfunction resetItemPosition(oldIndex?: number) {\n  items.value.forEach((item, index) => {\n    item.translateItem(index, activeIndex.value, oldIndex)\n  })\n}\n\nfunction addItem(item: CarouselItemContext) {\n  items.value.push(item)\n}\n\nfunction removeItem(uid?: number) {\n  const index = items.value.findIndex((item) => item.uid === uid)\n  if (index !== -1) {\n    items.value.splice(index, 1)\n    if (activeIndex.value === index) next()\n  }\n}\n\nfunction itemInStage(item: CarouselItemContext, index: number) {\n  const _items = unref(items)\n  const itemCount = _items.length\n  if (itemCount === 0 || !item.states.inStage) return false\n  const nextItemIndex = index + 1\n  const prevItemIndex = index - 1\n  const lastItemIndex = itemCount - 1\n  const isLastItemActive = _items[lastItemIndex].states.active\n  const isFirstItemActive = _items[0].states.active\n  const isNextItemActive = _items[nextItemIndex]?.states?.active\n  const isPrevItemActive = _items[prevItemIndex]?.states?.active\n\n  if ((index === lastItemIndex && isFirstItemActive) || isNextItemActive) {\n    return 'left'\n  } else if ((index === 0 && isLastItemActive) || isPrevItemActive) {\n    return 'right'\n  }\n  return false\n}\n\nfunction handleMouseEnter() {\n  hover.value = true\n  if (props.pauseOnHover) {\n    pauseTimer()\n  }\n}\n\nfunction handleMouseLeave() {\n  hover.value = false\n  startTimer()\n}\n\nfunction handleButtonEnter(arrow: 'left' | 'right') {\n  if (unref(isVertical)) return\n  items.value.forEach((item, index) => {\n    if (arrow === itemInStage(item, index)) {\n      item.states.hover = true\n    }\n  })\n}\n\nfunction handleButtonLeave() {\n  if (unref(isVertical)) return\n  items.value.forEach((item) => {\n    item.states.hover = false\n  })\n}\n\nfunction handleIndicatorClick(index: number) {\n  activeIndex.value = index\n}\n\nfunction handleIndicatorHover(index: number) {\n  if (props.trigger === 'hover' && index !== activeIndex.value) {\n    activeIndex.value = index\n  }\n}\n\nfunction prev() {\n  setActiveItem(activeIndex.value - 1)\n}\n\nfunction next() {\n  setActiveItem(activeIndex.value + 1)\n}\n\nfunction resetTimer() {\n  pauseTimer()\n  startTimer()\n}\n\n// watch\nwatch(\n  () => activeIndex.value,\n  (current, prev) => {\n    resetItemPosition(prev)\n    if (prev > -1) {\n      emit('change', current, prev)\n    }\n  }\n)\nwatch(\n  () => props.autoplay,\n  (autoplay) => {\n    autoplay ? startTimer() : pauseTimer()\n  }\n)\nwatch(\n  () => props.loop,\n  () => {\n    setActiveItem(activeIndex.value)\n  }\n)\n\nwatch(\n  () => props.interval,\n  () => {\n    resetTimer()\n  }\n)\n\nconst resizeObserver = shallowRef<ReturnType<typeof useResizeObserver>>()\n// lifecycle\nonMounted(async () => {\n  await nextTick()\n\n  resizeObserver.value = useResizeObserver(root.value, () => {\n    resetItemPosition()\n  })\n  if (props.initialIndex < items.value.length && props.initialIndex >= 0) {\n    activeIndex.value = props.initialIndex\n  }\n  startTimer()\n})\n\nonBeforeUnmount(() => {\n  pauseTimer()\n  if (root.value && resizeObserver.value) resizeObserver.value.stop()\n})\n\n// provide\nprovide(carouselContextKey, {\n  root,\n  isCardType,\n  isVertical,\n  items,\n  loop: props.loop,\n  addItem,\n  removeItem,\n  setActiveItem,\n})\n\ndefineExpose({\n  /** @description manually switch slide */\n  setActiveItem,\n  /** @description switch to the previous slide */\n  prev,\n  /** @description switch to the next slide */\n  next,\n})\n</script>\n","import { buildProps } from '@element-plus/utils'\nimport type { ExtractPropTypes } from 'vue'\nimport type CarouselItem from './carousel-item.vue'\n\nexport const carouselItemProps = buildProps({\n  name: { type: String, default: '' },\n  label: {\n    type: [String, Number],\n    default: '',\n  },\n} as const)\n\nexport type CarouselItemProps = ExtractPropTypes<typeof carouselItemProps>\n\nexport type CarouselItemInstance = InstanceType<typeof CarouselItem>\n","<template>\n  <div\n    v-show=\"ready\"\n    :class=\"[\n      ns.e('item'),\n      ns.is('active', active),\n      ns.is('in-stage', inStage),\n      ns.is('hover', hover),\n      ns.is('animating', animating),\n      { [ns.em('item', 'card')]: isCardType },\n    ]\"\n    :style=\"itemStyle\"\n    @click=\"handleItemClick\"\n  >\n    <div v-if=\"isCardType\" v-show=\"!active\" :class=\"ns.e('mask')\" />\n    <slot />\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  getCurrentInstance,\n  inject,\n  onMounted,\n  onUnmounted,\n  reactive,\n  ref,\n  unref,\n} from 'vue'\nimport { debugWarn, isUndefined } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { carouselContextKey } from '@element-plus/tokens'\nimport { carouselItemProps } from './carousel-item'\n\nimport type { CSSProperties } from 'vue'\n\ndefineOptions({\n  name: 'ElCarouselItem',\n})\n\nconst props = defineProps(carouselItemProps)\nconst ns = useNamespace('carousel')\nconst COMPONENT_NAME = 'ElCarouselItem'\n// inject\nconst carouselContext = inject(carouselContextKey)!\n// instance\nconst instance = getCurrentInstance()!\nif (!carouselContext) {\n  debugWarn(\n    COMPONENT_NAME,\n    'usage: <el-carousel></el-carousel-item></el-carousel>'\n  )\n}\n\nif (!instance) {\n  debugWarn(\n    COMPONENT_NAME,\n    'compositional hook can only be invoked inside setups'\n  )\n}\n\nconst CARD_SCALE = 0.83\n\nconst hover = ref(false)\nconst translate = ref(0)\nconst scale = ref(1)\nconst active = ref(false)\nconst ready = ref(false)\nconst inStage = ref(false)\nconst animating = ref(false)\n\n// computed\nconst { isCardType, isVertical } = carouselContext\n\nconst itemStyle = computed<CSSProperties>(() => {\n  const translateType = `translate${unref(isVertical) ? 'Y' : 'X'}`\n  const _translate = `${translateType}(${unref(translate)}px)`\n  const _scale = `scale(${unref(scale)})`\n  const transform = [_translate, _scale].join(' ')\n\n  return {\n    transform,\n  }\n})\n\n// methods\n\nfunction processIndex(index: number, activeIndex: number, length: number) {\n  const lastItemIndex = length - 1\n  const prevItemIndex = activeIndex - 1\n  const nextItemIndex = activeIndex + 1\n  const halfItemIndex = length / 2\n\n  if (activeIndex === 0 && index === lastItemIndex) {\n    return -1\n  } else if (activeIndex === lastItemIndex && index === 0) {\n    return length\n  } else if (index < prevItemIndex && activeIndex - index >= halfItemIndex) {\n    return length + 1\n  } else if (index > nextItemIndex && index - activeIndex >= halfItemIndex) {\n    return -2\n  }\n  return index\n}\n\nfunction calcCardTranslate(index: number, activeIndex: number) {\n  const parentWidth = carouselContext.root.value?.offsetWidth || 0\n  if (inStage.value) {\n    return (parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1)) / 4\n  } else if (index < activeIndex) {\n    return (-(1 + CARD_SCALE) * parentWidth) / 4\n  } else {\n    return ((3 + CARD_SCALE) * parentWidth) / 4\n  }\n}\n\nfunction calcTranslate(\n  index: number,\n  activeIndex: number,\n  isVertical: boolean\n) {\n  const rootEl = carouselContext.root.value\n  if (!rootEl) return 0\n\n  const distance = (isVertical ? rootEl.offsetHeight : rootEl.offsetWidth) || 0\n  return distance * (index - activeIndex)\n}\n\nconst translateItem = (\n  index: number,\n  activeIndex: number,\n  oldIndex?: number\n) => {\n  const _isCardType = unref(isCardType)\n  const carouselItemLength = carouselContext.items.value.length ?? Number.NaN\n\n  const isActive = index === activeIndex\n  if (!_isCardType && !isUndefined(oldIndex)) {\n    animating.value = isActive || index === oldIndex\n  }\n\n  if (!isActive && carouselItemLength > 2 && carouselContext.loop) {\n    index = processIndex(index, activeIndex, carouselItemLength)\n  }\n\n  const _isVertical = unref(isVertical)\n  active.value = isActive\n\n  if (_isCardType) {\n    if (_isVertical) {\n      debugWarn('Carousel', 'vertical direction is not supported for card mode')\n    }\n    inStage.value = Math.round(Math.abs(index - activeIndex)) <= 1\n    translate.value = calcCardTranslate(index, activeIndex)\n    scale.value = unref(active) ? 1 : CARD_SCALE\n  } else {\n    translate.value = calcTranslate(index, activeIndex, _isVertical)\n  }\n\n  ready.value = true\n}\n\nfunction handleItemClick() {\n  if (carouselContext && unref(isCardType)) {\n    const index = carouselContext.items.value.findIndex(\n      ({ uid }) => uid === instance.uid\n    )\n    carouselContext.setActiveItem(index)\n  }\n}\n\n// lifecycle\nonMounted(() => {\n  carouselContext.addItem({\n    props,\n    states: reactive({\n      hover,\n      translate,\n      scale,\n      active,\n      ready,\n      inStage,\n      animating,\n    }),\n    uid: instance.uid,\n    translateItem,\n  })\n})\n\nonUnmounted(() => {\n  carouselContext.removeItem(instance.uid)\n})\n</script>\n","import { withInstall, withNoopInstall } from '@element-plus/utils'\nimport Carousel from './src/carousel.vue'\nimport CarouselItem from './src/carousel-item.vue'\n\nexport const ElCarousel = withInstall(Carousel, {\n  CarouselItem,\n})\n\nexport default ElCarousel\n\nexport const ElCarouselItem = withNoopInstall(CarouselItem)\n\nexport * from './src/carousel'\nexport * from './src/carousel-item'\n","const ET011 = require('../../assets/images/home/ET011.jpg')\nconst FS008AP = require('../../assets/images/home/FS008AP.jpg')\nconst LS003AP_WHITE = require('../../assets/images/home/LS003AP-WHITE.jpg')\n\nconst imgList = [ET011, FS008AP, LS003AP_WHITE]\n\nexport {\n  imgList\n}\n","\nimport { defineComponent } from 'vue'\nimport { ElCarousel, ElCarouselItem } from 'element-plus'\nimport { imgList } from './util'\nimport './index.scss'\nexport default defineComponent({\n  name: 'home-index',\n  components: {\n  },\n  // setup() {\n      \n  // },\n  data () {\n    return {\n      imgList,\n      urls: ['/small-chair-and-end-table', '/flower-shelf', '/livingRoom-shelf']\n    }\n  },\n  methods: {\n    imgClick (index: number) {\n      let src = this.urls[index]\n      src && this.$router.push(src)\n    }\n  },\n  render () {\n    return <div class=\"home-wrap\">\n      <ElCarousel height={'400px'} >\n        {\n          imgList.map((item, index) => {\n            return <ElCarouselItem key={index}>\n              <img onClick={this.imgClick.bind(this, index)} class=\"ElCarouselItem-img\" src={item} alt=\"\"></img>\n            </ElCarouselItem>\n          })\n        }\n      </ElCarousel>\n    </div>\n  }\n})\n","import script from \"./index.vue?vue&type=script&lang=tsx\"\nexport * from \"./index.vue?vue&type=script&lang=tsx\"\n\nconst __exports__ = script;\n\nexport default __exports__","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n","import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n","import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n","import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n","import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n","import debounce from './debounce.js';\nimport isObject from './isObject.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nexport default throttle;\n"],"names":["carouselProps","buildProps","initialIndex","type","Number","default","height","String","trigger","values","autoplay","Boolean","interval","indicatorPosition","indicator","arrow","loop","direction","pauseOnHover","carouselEmits","change","current","prev","every","isNumber","carouselContextKey","Symbol","ns","COMPONENT_NAME","THROTTLE_TIME","activeIndex","timer","hover","root","items","arrowDisplay","hasLabel","carouselClasses","classes","indicatorsClasses","isCardType","props","isVertical","throttledArrowClick","throttle","setActiveItem","trailing","throttledIndicatorHover","handleIndicatorHover","pauseTimer","clearInterval","startTimer","playSlides","index","item","debugWarn","resetItemPosition","resetTimer","oldIndex","addItem","removeItem","uid","itemInStage","watch","emit","onMounted","resizeObserver","onBeforeUnmount","provide","expose","next","carouselItemProps","name","label","carouselContext","instance","CARD_SCALE","translate","scale","active","ready","inStage","animating","itemStyle","transform","processIndex","calcCardTranslate","states","translateItem","onUnmounted","ElCarousel","withInstall","Carousel","CarouselItem","ElCarouselItem","withNoopInstall","ET011","require","FS008AP","LS003AP_WHITE","imgList","defineComponent","components","data","urls","methods","imgClick","src","this","$router","push","render","map","bind","__exports__","objectProto","Object","prototype","hasOwnProperty","nativeObjectToString","toString","symToStringTag","undefined","getRawTag","value","isOwn","call","tag","unmasked","e","result","objectToString","nullTag","undefinedTag","baseGetTag","freeGlobal","global","freeSelf","self","Function","isObject","isObjectLike","symbolTag","isSymbol","now","reWhitespace","trimmedEndIndex","string","length","test","charAt","reTrimStart","baseTrim","slice","replace","NAN","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","toNumber","other","valueOf","isBinary","FUNC_ERROR_TEXT","nativeMax","Math","max","nativeMin","min","debounce","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","TypeError","invokeFunc","time","args","thisArg","apply","leadingEdge","setTimeout","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","timeWaiting","shouldInvoke","trailingEdge","cancel","clearTimeout","flush","debounced","isInvoking","arguments"],"sourceRoot":""}